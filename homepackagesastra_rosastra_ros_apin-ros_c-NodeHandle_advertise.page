{"name":"homepackagesastra_rosastra_ros_apin-ros_c-NodeHandle_advertise","symbols":{"homepackagesastra_rosastra_ros_apin-ros_c-NodeHandle_advertise":{"type":"function","name":"homepackagesastra_rosastra_ros_apin-ros_c-NodeHandle_advertise","display_name":"advertise","comment":[{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"brief","arguments":[],"children":[{"type":"text","text":" Advertise a topic, with most of the available options, including subscriber status callbacks"}]},{"type":"paragraph","children":[{"type":"text","text":" This call connects to the master to publicize that the node will be"},{"type":"text","text":" publishing messages on the given topic.  This method returns a Publisher that allows you to"},{"type":"text","text":" publish a message on this topic."}]},{"type":"paragraph","children":[{"type":"text","text":" This version of advertise allows you to pass functions to be called when new subscribers connect and"},{"type":"text","text":" disconnect.  With bare functions it can be used like so:"},{"type":"text","text":"     "}]},{"type":"verbatimcommand","parts":["     void connectCallback(const ros::SingleSubscriberPublisher& pub)","     {","     // Do something","     }","\n     handle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)connectCallback);\n     \\endverbatim\n     *\n     * With class member functions it can be used with boost::bind:\n     \\verbatim\n     void MyClass::connectCallback(const ros::SingleSubscriberPublisher& pub)\n     {\n     // Do something\n     }\n\n     MyClass my_class;\n     ros::Publisher pub = handle.advertise<std_msgs::Empty>(\"my_topic\", 1, \n                                                            boost::bind(&MyClass::connectCallback, my_class, _1));\n     \\endverbatim\n     *\n   *\n   * \\param topic Topic to advertise on\n   *\n   * \\param queue_size Maximum number of outgoing messages to be queued for delivery to subscribers\n   *\n   * \\param connect_cb Function to call when a subscriber connects\n   *\n   * \\param disconnect_cb (optional) Function to call when a subscriber disconnects\n     *\n   * \\param tracked_object (optional) A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param latch (optional) If true, the last message published on this topic will be saved and sent to new subscribers when they connect\n   * \\return On success, a Publisher that, when it goes out of scope, will automatically release a reference\n   * on this advertisement.  On failure, an empty Publisher which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nros::publisher pub = nodeHandle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)callback);\nif (pub)  // Enter if publisher is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template <class M>\n  Publisher advertise(const std::string& topic, uint32_t queue_size,\n                            const SubscriberStatusCallback& connect_cb,\n                            const SubscriberStatusCallback& disconnect_cb = SubscriberStatusCallback(),\n                            const VoidConstPtr& tracked_object = VoidConstPtr(),\n                            bool latch = false)\n  {\n    AdvertiseOptions ops;\n    ops.template init<M>(topic, queue_size, connect_cb, disconnect_cb);\n    ops.tracked_object = tracked_object;\n    ops.latch = latch;\n    return advertise(ops);\n  }\n\n  /**\n   * \\brief Advertise a topic, with full range of AdvertiseOptions\n   *\n   * This call connects to the master to publicize that the node will be\n   * publishing messages on the given topic.  This method returns a Publisher that allows you to\n   * publish a message on this topic.\n   *\n   * This is an advanced version advertise() that exposes all options (through the AdvertiseOptions structure)\n   *\n   * \\param ops Advertise options to use\n   * \\return On success, a Publisher that, when it goes out of scope, will automatically release a reference\n   * on this advertisement.  On failure, an empty Publisher which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nros::AdvertiseOptions ops;\n...\nros::publisher pub = nodeHandle.advertise(ops);\nif (pub)  // Enter if publisher is valid\n{\n...\n}\n\\endverbatim\n   *\n   * \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  Publisher advertise(AdvertiseOptions& ops);\n\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of subscribe()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Subscribe to a topic, version for class member function with bare pointer\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions, and can be used like so:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nFoo foo_object;\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /// and the const version\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M) const, T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with bare pointer\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions, and can be used like so:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nFoo foo_object;\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&), T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&) const, T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with shared_ptr\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions on a shared_ptr:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr\n   * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M) const, \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with shared_ptr\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions on a shared_ptr:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr\n   * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&), \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&) const, \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for bare function\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, callback);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Function pointer to call when a message has arrived\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(M), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, fp);\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for bare function\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, callback);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Function pointer to call when a message has arrived\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(const boost::shared_ptr<M const>&), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, fp);\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for arbitrary boost::function object\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, callback is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows anything bindable to a boost::function object\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param callback Callback to call when a message has arrived\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (const boost::shared_ptr<M const>&)>& callback,\n                             const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, callback);\n    ops.tracked_object = tracked_object;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for arbitrary boost::function object\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, callback is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows anything bindable to a boost::function object\n   *\n   * \\param M [template] the message type\n   * \\param C [template] the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&)\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param callback Callback to call when a message has arrived\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class C>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (C)>& callback,\n                             const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<C>(topic, queue_size, callback);\n    ops.tracked_object = tracked_object;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version with full range of SubscribeOptions\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows the full range of options, exposed through the SubscribeOptions class\n   *\n   * \\param ops Subscribe options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nSubscribeOptions ops;\n...\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(ops);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  Subscriber subscribe(SubscribeOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of advertiseService()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Advertise a service, version for class member function with bare pointer\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions, and can be used like so:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nFoo foo_object;\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(MReq &, MRes &), T *obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, boost::bind(srv_func, obj, _1, _2));\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with bare pointer using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions, and can be used like so:\n\\verbatim\nbool Foo::callback(ros::ServiceEvent<std_srvs::Empty::Request, std_srvs::Empty::Response>& event)\n{\n  return true;\n}\n\nFoo foo_object;\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), T *obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj, _1));\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with shared_ptr\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions on shared pointers, and can be used like so:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,\n   * and if the object is deleted the service callback will stop being called (and therefore will not crash).\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(MReq &, MRes &), const boost::shared_ptr<T>& obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, boost::bind(srv_func, obj.get(), _1, _2));\n    ops.tracked_object = obj;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with shared_ptr using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions on shared pointers, and can be used like so:\n\\verbatim\nbool Foo::callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)\n{\n  return true;\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,\n   * and if the object is deleted the service callback will stop being called (and therefore will not crash).\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), const boost::shared_ptr<T>& obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj.get(), _1));\n    ops.tracked_object = obj;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for bare function\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nbool callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nros::ServiceServer service = handle.advertiseService(\"my_service\", callback);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func function pointer to call when a message has arrived\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(*srv_func)(MReq&, MRes&))\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, srv_func);\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for bare function using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nbool callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)\n{\n  return true;\n}\n\nros::ServiceServer service = handle.advertiseService(\"my_service\", callback);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func function pointer to call when a message has arrived\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(*srv_func)(ServiceEvent<MReq, MRes>&))\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, srv_func);\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for arbitrary boost::function object\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything\n   * else boost::function supports).\n   *\n   * \\param service Service name to advertise on\n   * \\param callback Callback to call when the service is called\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, const boost::function<bool(MReq&, MRes&)>& callback, \n                                 const VoidConstPtr& tracked_object = VoidConstPtr())\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, callback);\n    ops.tracked_object = tracked_object;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for arbitrary boost::function object using ros::ServiceEvent as the callback parameter type\n   *\n   * Note that the template parameter S is the full event type, e.g. ros::ServiceEvent<Req, Res>\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything\n   * else boost::function supports).\n   *\n   * \\param service Service name to advertise on\n   * \\param callback Callback to call when the service is called\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class S>\n  ServiceServer advertiseService(const std::string& service, const boost::function<bool(S&)>& callback, \n                                 const VoidConstPtr& tracked_object = VoidConstPtr())\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<S>(service, callback);\n    ops.tracked_object = tracked_object;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, with full range of AdvertiseServiceOptions\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows the full set of options, exposed through the AdvertiseServiceOptions class\n   *\n   * \\param ops Advertise options\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nAdvertiseServiceOptions ops;\n...\nros::NodeHandle nodeHandle;\nros::ServiceServer service = nodeHandle.advertiseService(ops);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  ServiceServer advertiseService(AdvertiseServiceOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of serviceClient()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /** @brief Create a client for a service, version templated on two message types\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param service_name The name of the service to connect to\n   * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active\n   *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as\n   *        robust to node failure as non-persistent services.\n   * @param header_values Key/value pairs you'd like to send along in the connection handshake\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceClient serviceClient(const std::string& service_name, bool persistent = false, \n                              const M_string& header_values = M_string())\n  {\n    ServiceClientOptions ops;\n    ops.template init<MReq, MRes>(service_name, persistent, header_values);\n    return serviceClient(ops);\n  }\n\n  /** @brief Create a client for a service, version templated on service type\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param service_name The name of the service to connect to\n   * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active\n   *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as\n   *        robust to node failure as non-persistent services.\n   * @param header_values Key/value pairs you'd like to send along in the connection handshake\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class Service>\n  ServiceClient serviceClient(const std::string& service_name, bool persistent = false, \n                              const M_string& header_values = M_string())\n  {\n    ServiceClientOptions ops;\n    ops.template init<Service>(service_name, persistent, header_values);\n    return serviceClient(ops);\n  }\n\n  /** @brief Create a client for a service, version with full range of ServiceClientOptions\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param ops The options for this service client\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  ServiceClient serviceClient(ServiceClientOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param r The rate at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class Handler, class Obj>\n  Timer createTimer(Rate r, Handler h, Obj o, bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(r.expectedCycleTime(), h, o, oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&) const, T* obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&), T* obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&), const boost::shared_ptr<T>& obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    TimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  Timer createTimer(Duration period, const TimerCallback& callback, bool oneshot = false,\n                    bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  Timer createTimer(TimerOptions& ops) const;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createWallTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.\n   * This variant takes a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  WallTimer createWallTimer(WallDuration period, void(T::*callback)(const WallTimerEvent&), T* obj, \n                            bool oneshot = false, bool autostart = true) const\n  {\n    return createWallTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   */\n  template<class T>\n  WallTimer createWallTimer(WallDuration period, void(T::*callback)(const WallTimerEvent&), \n                            const boost::shared_ptr<T>& obj, \n                            bool oneshot = false, bool autostart = true) const\n  {\n    WallTimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createWallTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   */\n  WallTimer createWallTimer(WallDuration period, const WallTimerCallback& callback, \n                            bool oneshot = false, bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  WallTimer createWallTimer(WallTimerOptions& ops) const;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createSteadyTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.\n   * This variant takes a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  SteadyTimer createSteadyTimer(WallDuration period, void(T::*callback)(const SteadyTimerEvent&), T* obj,\n                                bool oneshot = false, bool autostart = true) const\n  {\n    return createSteadyTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   */\n  template<class T>\n  SteadyTimer createSteadyTimer(WallDuration period, void(T::*callback)(const SteadyTimerEvent&),\n                                const boost::shared_ptr<T>& obj,\n                                bool oneshot = false, bool autostart = true) const\n  {\n    SteadyTimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createSteadyTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   */\n  SteadyTimer createSteadyTimer(WallDuration period, const SteadyTimerCallback& callback,\n                                bool oneshot = false, bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  SteadyTimer createSteadyTimer(SteadyTimerOptions& ops) const;\n\n  /** \\brief Set an arbitrary XML/RPC value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param v The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const XmlRpc::XmlRpcValue& v) const;\n  /** \\brief Set a string value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param s The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::string& s) const;\n  /** \\brief Set a string value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param s The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const char* s) const;\n  /** \\brief Set a double value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param d The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, double d) const;\n  /** \\brief Set an integer value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param i The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, int i) const;\n  /** \\brief Set a boolean value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param b The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, bool b) const;\n\n  /** \\brief Set a string vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<std::string>& vec) const;\n  /** \\brief Set a double vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<double>& vec) const;\n  /** \\brief Set a float vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<float>& vec) const;\n  /** \\brief Set a int vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<int>& vec) const;\n  /** \\brief Set a bool vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<bool>& vec) const;\n\n  /** \\brief Set a string vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, std::string>& map) const;\n  /** \\brief Set a double vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, double>& map) const;\n  /** \\brief Set a float vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, float>& map) const;\n  /** \\brief Set a int vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, int>& map) const;\n  /** \\brief Set a bool vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, bool>& map) const;\n\n  /** \\brief Get a string value from the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] s Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::string& s) const;\n  /** \\brief Get a double value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] d Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, double& d) const;\n  /** \\brief Get a float value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] f Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, float& f) const;\n  /** \\brief Get an integer value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] i Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, int& i) const;\n  /** \\brief Get a boolean value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] b Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, bool& b) const;\n  /** \\brief Get an arbitrary XML/RPC value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] v Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, XmlRpc::XmlRpcValue& v) const;\n\n  /** \\brief Get a string vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<std::string>& vec) const;\n  /** \\brief Get a double vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<double>& vec) const;\n  /** \\brief Get a float vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<float>& vec) const;\n  /** \\brief Get an int vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<int>& vec) const;\n  /** \\brief Get a boolean vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<bool>& vec) const;\n\n  /** \\brief Get a string map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, std::string>& map) const;\n  /** \\brief Get a double map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, double>& map) const;\n  /** \\brief Get a float map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, float>& map) const;\n  /** \\brief Get an int map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, int>& map) const;\n  /** \\brief Get a boolean map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, bool>& map) const;\n\n  /** \\brief Get a string value from the parameter server, with local caching\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] s Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::string& s) const;\n  /** \\brief Get a double value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] d Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, double& d) const;\n  /** \\brief Get a float value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] f Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, float& f) const;\n  /** \\brief Get an integer value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] i Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, int& i) const;\n  /** \\brief Get a boolean value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] b Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, bool& b) const;\n  /** \\brief Get an arbitrary XML/RPC value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] v Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, XmlRpc::XmlRpcValue& v) const;\n\n  /** \\brief Get a std::string vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<std::string>& vec) const;\n  /** \\brief Get a double vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<double>& vec) const;\n  /** \\brief Get a float vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<float>& vec) const;\n  /** \\brief Get a int vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<int>& vec) const;\n  /** \\brief Get a bool vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<bool>& vec) const;\n\n  /** \\brief Get a string->std::string map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, std::string>& map) const;\n  /** \\brief Get a string->double map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, double>& map) const;\n  /** \\brief Get a string->float map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, float>& map) const;\n  /** \\brief Get a string->int map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, int>& map) const;\n  /** \\brief Get a string->bool map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, bool>& map) const;\n\n  /** \\brief Check whether a parameter exists on the parameter server.\n   *\n   * \\param key The key to check.\n   *\n   * \\return true if the parameter exists, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool hasParam(const std::string& key) const;\n  /** \\brief Search up the tree for a parameter with a given key\n   *\n   * This function parameter server's searchParam feature to search up the tree for\n   * a parameter.  For example, if the parameter server has a parameter [/a/b]\n   * and you're in the namespace [/a/c/d], searching for the parameter \"b\" will\n   * yield [/a/b].  If [/a/c/d/b] existed, that parameter would be returned instead.\n   *\n   * \\param key the parameter to search for\n   * \\param [out] result the found value (if any)\n   *\n   * \\return true if the parameter was found, false otherwise.\n   */\n  bool searchParam(const std::string& key, std::string& result) const;\n  /** \\brief Delete a parameter from the parameter server.\n   *\n   * \\param key The key to delete.\n   *\n   * \\return true if the deletion succeeded, false otherwise.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool deleteParam(const std::string& key) const;\n\n  /** \\brief Get the keys for all the parameters in the parameter server.\n   * \\param keys The keys retrieved.\n   * \\return true if the query succeeded, false otherwise.\n   */\n  bool getParamNames(std::vector<std::string>& keys) const;\n\n  /** \\brief Assign value from parameter server, with default.\n   *\n   * This method tries to retrieve the indicated parameter value from the\n   * parameter server, storing the result in param_val.  If the value\n   * cannot be retrieved from the server, default_val is used instead.\n   *\n   * \\param param_name The key to be searched on the parameter server.\n   * \\param[out] param_val Storage for the retrieved value.\n   * \\param default_val Value to use if the server doesn't contain this\n   * parameter.\n   * \\return true if the parameter was retrieved from the server, false otherwise.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<typename T>\n  bool param(const std::string& param_name, T& param_val, const T& default_val) const\n  {\n    if (hasParam(param_name))\n    {\n      if (getParam(param_name, param_val))\n      {\n        return true;\n      }\n    }\n\n    param_val = default_val;\n    return false;\n  }\n\n  /**\n   * \\brief Return value from parameter server, or default if unavailable.\n   *\n   * This method tries to retrieve the indicated parameter value from the\n   * parameter server. If the parameter cannot be retrieved, \\c default_val\n   * is returned instead.\n   *\n   * \\param param_name The key to be searched on the parameter server.\n   *\n   * \\param default_val Value to return if the server doesn't contain this\n   * parameter.\n   *\n   * \\return The parameter value retrieved from the parameter server, or\n   * \\c default_val if unavailable.\n   *\n   * \\throws InvalidNameException If the parameter key begins with a tilde,\n   * or is an otherwise invalid graph resource name.\n   */\n  template<typename T>\n  T param(const std::string& param_name, const T& default_val) const\n  {\n      T param_val;\n      param(param_name, param_val, default_val);\n      return param_val;\n  }\n\n  /**\n   * \\brief Shutdown every handle created through this NodeHandle.\n   *\n   * This method will unadvertise every topic and service advertisement,\n   * and unsubscribe every subscription created through this NodeHandle.\n   */\n  void shutdown();\n\n  /** \\brief Check whether it's time to exit.\n   *\n   * This method checks to see if both ros::ok() is true and shutdown() has not been called on this NodeHandle, to see whether it's yet time\n   * to exit.  ok() is false once either ros::shutdown() or NodeHandle::shutdown() have been called\n   *\n   * \\return true if we're still OK, false if it's time to exit\n   */\n  bool ok() const;\n\nprivate:\n  struct no_validate { };\n  // this is pretty awful, but required to preserve public interface (and make minimum possible changes)\n  std::string resolveName(const std::string& name, bool remap, no_validate) const;\n\n  void construct(const std::string& ns, bool validate_name);\n  void destruct();\n\n  void initRemappings(const M_string& remappings);\n\n  std::string remapName(const std::string& name) const;\n\n  std::string namespace_;\n  std::string unresolved_namespace_;\n  M_string remappings_;\n  M_string unresolved_remappings_;\n\n  CallbackQueueInterface* callback_queue_;\n\n  NodeHandleBackingCollection* collection_;\n\n  bool ok_;\n};\n\n}\n\n#endif // ROSCPP_NODE_HANDLE_H\n","     handle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)connectCallback);"]},{"type":"paragraph","children":[{"type":"text","text":" With class member functions it can be used with boost::bind:"},{"type":"text","text":"     "}]},{"type":"verbatimcommand","parts":["     void MyClass::connectCallback(const ros::SingleSubscriberPublisher& pub)","     {","     // Do something","     }","\n     MyClass my_class;\n     ros::Publisher pub = handle.advertise<std_msgs::Empty>(\"my_topic\", 1, \n                                                            boost::bind(&MyClass::connectCallback, my_class, _1));\n     \\endverbatim\n     *\n   *\n   * \\param topic Topic to advertise on\n   *\n   * \\param queue_size Maximum number of outgoing messages to be queued for delivery to subscribers\n   *\n   * \\param connect_cb Function to call when a subscriber connects\n   *\n   * \\param disconnect_cb (optional) Function to call when a subscriber disconnects\n     *\n   * \\param tracked_object (optional) A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param latch (optional) If true, the last message published on this topic will be saved and sent to new subscribers when they connect\n   * \\return On success, a Publisher that, when it goes out of scope, will automatically release a reference\n   * on this advertisement.  On failure, an empty Publisher which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nros::publisher pub = nodeHandle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)callback);\nif (pub)  // Enter if publisher is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template <class M>\n  Publisher advertise(const std::string& topic, uint32_t queue_size,\n                            const SubscriberStatusCallback& connect_cb,\n                            const SubscriberStatusCallback& disconnect_cb = SubscriberStatusCallback(),\n                            const VoidConstPtr& tracked_object = VoidConstPtr(),\n                            bool latch = false)\n  {\n    AdvertiseOptions ops;\n    ops.template init<M>(topic, queue_size, connect_cb, disconnect_cb);\n    ops.tracked_object = tracked_object;\n    ops.latch = latch;\n    return advertise(ops);\n  }\n\n  /**\n   * \\brief Advertise a topic, with full range of AdvertiseOptions\n   *\n   * This call connects to the master to publicize that the node will be\n   * publishing messages on the given topic.  This method returns a Publisher that allows you to\n   * publish a message on this topic.\n   *\n   * This is an advanced version advertise() that exposes all options (through the AdvertiseOptions structure)\n   *\n   * \\param ops Advertise options to use\n   * \\return On success, a Publisher that, when it goes out of scope, will automatically release a reference\n   * on this advertisement.  On failure, an empty Publisher which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nros::AdvertiseOptions ops;\n...\nros::publisher pub = nodeHandle.advertise(ops);\nif (pub)  // Enter if publisher is valid\n{\n...\n}\n\\endverbatim\n   *\n   * \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  Publisher advertise(AdvertiseOptions& ops);\n\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of subscribe()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Subscribe to a topic, version for class member function with bare pointer\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions, and can be used like so:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nFoo foo_object;\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /// and the const version\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M) const, T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with bare pointer\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions, and can be used like so:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nFoo foo_object;\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&), T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&) const, T* obj, \n                       const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj, _1));\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with shared_ptr\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions on a shared_ptr:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr\n   * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M), \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(T::*fp)(M) const, \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for class member function with shared_ptr\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using member functions on a shared_ptr:\n\\verbatim\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Member function pointer to call when a message has arrived\n   * \\param obj Object to call fp on.  Since this is a shared pointer, the object will automatically be tracked with a weak_ptr\n   * so that if it is deleted before the Subscriber goes out of scope the callback will no longer be called (and therefore will not crash).\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nros::NodeHandle nodeHandle;\nvoid Foo::callback(const std_msgs::Empty::ConstPtr& message) {}\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, &Foo::callback, foo_object);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&), \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n  template<class M, class T>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, \n                       void(T::*fp)(const boost::shared_ptr<M const>&) const, \n                       const boost::shared_ptr<T>& obj, const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, boost::bind(fp, obj.get(), _1));\n    ops.tracked_object = obj;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for bare function\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, callback);\n\\endverbatim\n   *\n   * \\param M [template] M here is the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&), \\b not the message type, and should almost always be deduced\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Function pointer to call when a message has arrived\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(M), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<M>(topic, queue_size, fp);\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for bare function\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message)\n{\n}\n\nros::Subscriber sub = handle.subscribe(\"my_topic\", 1, callback);\n\\endverbatim\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param fp Function pointer to call when a message has arrived\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, void(*fp)(const boost::shared_ptr<M const>&), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, fp);\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for arbitrary boost::function object\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, callback is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows anything bindable to a boost::function object\n   *\n   * \\param M [template] M here is the message type\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param callback Callback to call when a message has arrived\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (const boost::shared_ptr<M const>&)>& callback,\n                             const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template init<M>(topic, queue_size, callback);\n    ops.tracked_object = tracked_object;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version for arbitrary boost::function object\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, callback is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows anything bindable to a boost::function object\n   *\n   * \\param M [template] the message type\n   * \\param C [template] the callback parameter type (e.g. const boost::shared_ptr<M const>& or const M&)\n   * \\param topic Topic to subscribe to\n   * \\param queue_size Number of incoming messages to queue up for\n   * processing (messages in excess of this queue capacity will be\n   * discarded).\n   * \\param callback Callback to call when a message has arrived\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\param transport_hints a TransportHints structure which defines various transport-related options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nvoid callback(const std_msgs::Empty::ConstPtr& message){...}\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(\"my_topic\", 1, callback);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  template<class M, class C>\n  Subscriber subscribe(const std::string& topic, uint32_t queue_size, const boost::function<void (C)>& callback,\n                             const VoidConstPtr& tracked_object = VoidConstPtr(), const TransportHints& transport_hints = TransportHints())\n  {\n    SubscribeOptions ops;\n    ops.template initByFullCallbackType<C>(topic, queue_size, callback);\n    ops.tracked_object = tracked_object;\n    ops.transport_hints = transport_hints;\n    return subscribe(ops);\n  }\n\n  /**\n   * \\brief Subscribe to a topic, version with full range of SubscribeOptions\n   *\n   * This method connects to the master to register interest in a given\n   * topic.  The node will automatically be connected with publishers on\n   * this topic.  On each message receipt, fp is invoked and passed a shared pointer\n   * to the message received.  This message should \\b not be changed in place, as it\n   * is shared with any other subscriptions to this topic.\n   *\n   * This version of subscribe allows the full range of options, exposed through the SubscribeOptions class\n   *\n   * \\param ops Subscribe options\n   * \\return On success, a Subscriber that, when all copies of it go out of scope, will unsubscribe from this topic.\n   * On failure, an empty Subscriber which can be checked with:\n\\verbatim\nSubscribeOptions ops;\n...\nros::NodeHandle nodeHandle;\nros::Subscriber sub = nodeHandle.subscribe(ops);\nif (sub)  // Enter if subscriber is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name\n   *  \\throws ConflictingSubscriptionException If this node is already subscribed to the same topic with a different datatype\n   */\n  Subscriber subscribe(SubscribeOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of advertiseService()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Advertise a service, version for class member function with bare pointer\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions, and can be used like so:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nFoo foo_object;\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(MReq &, MRes &), T *obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, boost::bind(srv_func, obj, _1, _2));\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with bare pointer using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions, and can be used like so:\n\\verbatim\nbool Foo::callback(ros::ServiceEvent<std_srvs::Empty::Request, std_srvs::Empty::Response>& event)\n{\n  return true;\n}\n\nFoo foo_object;\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   *  \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), T *obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj, _1));\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with shared_ptr\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions on shared pointers, and can be used like so:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,\n   * and if the object is deleted the service callback will stop being called (and therefore will not crash).\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(MReq &, MRes &), const boost::shared_ptr<T>& obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, boost::bind(srv_func, obj.get(), _1, _2));\n    ops.tracked_object = obj;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for class member function with shared_ptr using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using member functions on shared pointers, and can be used like so:\n\\verbatim\nbool Foo::callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)\n{\n  return true;\n}\n\nboost::shared_ptr<Foo> foo_object(boost::make_shared<Foo>());\nros::ServiceServer service = handle.advertiseService(\"my_service\", &Foo::callback, foo_object);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func Member function pointer to call when a message has arrived\n   * \\param obj Object to call srv_func on.  Since this is a shared_ptr, it will automatically be tracked with a weak_ptr,\n   * and if the object is deleted the service callback will stop being called (and therefore will not crash).\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", &Foo::callback, &foo_object);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class T, class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(T::*srv_func)(ServiceEvent<MReq, MRes>&), const boost::shared_ptr<T>& obj)\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, boost::bind(srv_func, obj.get(), _1));\n    ops.tracked_object = obj;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for bare function\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nbool callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\n\nros::ServiceServer service = handle.advertiseService(\"my_service\", callback);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func function pointer to call when a message has arrived\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(*srv_func)(MReq&, MRes&))\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, srv_func);\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for bare function using ros::ServiceEvent as the callback parameter type\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This is a convenience function for using bare functions, and can be used like so:\n\\verbatim\nbool callback(ros::ServiceEvent<std_srvs::Empty, std_srvs::Empty>& event)\n{\n  return true;\n}\n\nros::ServiceServer service = handle.advertiseService(\"my_service\", callback);\n\\endverbatim\n   *\n   * \\param service Service name to advertise on\n   * \\param srv_func function pointer to call when a message has arrived\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, bool(*srv_func)(ServiceEvent<MReq, MRes>&))\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<ServiceEvent<MReq, MRes> >(service, srv_func);\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for arbitrary boost::function object\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything\n   * else boost::function supports).\n   *\n   * \\param service Service name to advertise on\n   * \\param callback Callback to call when the service is called\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceServer advertiseService(const std::string& service, const boost::function<bool(MReq&, MRes&)>& callback, \n                                 const VoidConstPtr& tracked_object = VoidConstPtr())\n  {\n    AdvertiseServiceOptions ops;\n    ops.template init<MReq, MRes>(service, callback);\n    ops.tracked_object = tracked_object;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, version for arbitrary boost::function object using ros::ServiceEvent as the callback parameter type\n   *\n   * Note that the template parameter S is the full event type, e.g. ros::ServiceEvent<Req, Res>\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows non-class functions, as well as functor objects and boost::bind (along with anything\n   * else boost::function supports).\n   *\n   * \\param service Service name to advertise on\n   * \\param callback Callback to call when the service is called\n   * \\param tracked_object A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,\n   * and if the reference count goes to 0 the subscriber callbacks will not get called.\n   * Note that setting this will cause a new reference to be added to the object before the\n   * callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore\n   * thread) that the callback is invoked from.\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nbool Foo::callback(std_srvs::Empty& request, std_srvs::Empty& response)\n{\n  return true;\n}\nros::NodeHandle nodeHandle;\nFoo foo_object;\nros::ServiceServer service = nodeHandle.advertiseService(\"my_service\", callback);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class S>\n  ServiceServer advertiseService(const std::string& service, const boost::function<bool(S&)>& callback, \n                                 const VoidConstPtr& tracked_object = VoidConstPtr())\n  {\n    AdvertiseServiceOptions ops;\n    ops.template initBySpecType<S>(service, callback);\n    ops.tracked_object = tracked_object;\n    return advertiseService(ops);\n  }\n\n  /**\n   * \\brief Advertise a service, with full range of AdvertiseServiceOptions\n   *\n   * This call connects to the master to publicize that the node will be\n   * offering an RPC service with the given name.\n   *\n   * This version of advertiseService allows the full set of options, exposed through the AdvertiseServiceOptions class\n   *\n   * \\param ops Advertise options\n   * \\return On success, a ServiceServer that, when all copies of it go out of scope, will unadvertise this service.\n   * On failure, an empty ServiceServer which can be checked with:\n\\verbatim\nAdvertiseServiceOptions ops;\n...\nros::NodeHandle nodeHandle;\nros::ServiceServer service = nodeHandle.advertiseService(ops);\nif (service)  // Enter if advertised service is valid\n{\n...\n}\n\\endverbatim\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  ServiceServer advertiseService(AdvertiseServiceOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of serviceClient()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /** @brief Create a client for a service, version templated on two message types\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param service_name The name of the service to connect to\n   * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active\n   *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as\n   *        robust to node failure as non-persistent services.\n   * @param header_values Key/value pairs you'd like to send along in the connection handshake\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class MReq, class MRes>\n  ServiceClient serviceClient(const std::string& service_name, bool persistent = false, \n                              const M_string& header_values = M_string())\n  {\n    ServiceClientOptions ops;\n    ops.template init<MReq, MRes>(service_name, persistent, header_values);\n    return serviceClient(ops);\n  }\n\n  /** @brief Create a client for a service, version templated on service type\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param service_name The name of the service to connect to\n   * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active\n   *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as\n   *        robust to node failure as non-persistent services.\n   * @param header_values Key/value pairs you'd like to send along in the connection handshake\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<class Service>\n  ServiceClient serviceClient(const std::string& service_name, bool persistent = false, \n                              const M_string& header_values = M_string())\n  {\n    ServiceClientOptions ops;\n    ops.template init<Service>(service_name, persistent, header_values);\n    return serviceClient(ops);\n  }\n\n  /** @brief Create a client for a service, version with full range of ServiceClientOptions\n   *\n   * When the last handle reference of a persistent connection is cleared, the connection will automatically close.\n   *\n   * @param ops The options for this service client\n   * \\throws InvalidNameException If the service name begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  ServiceClient serviceClient(ServiceClientOptions& ops);\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param r The rate at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class Handler, class Obj>\n  Timer createTimer(Rate r, Handler h, Obj o, bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(r.expectedCycleTime(), h, o, oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&) const, T* obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&), T* obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    return createTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  Timer createTimer(Duration period, void(T::*callback)(const TimerEvent&), const boost::shared_ptr<T>& obj, \n                    bool oneshot = false, bool autostart = true) const\n  {\n    TimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  Timer createTimer(Duration period, const TimerCallback& callback, bool oneshot = false,\n                    bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  Timer createTimer(TimerOptions& ops) const;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createWallTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.\n   * This variant takes a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  WallTimer createWallTimer(WallDuration period, void(T::*callback)(const WallTimerEvent&), T* obj, \n                            bool oneshot = false, bool autostart = true) const\n  {\n    return createWallTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   */\n  template<class T>\n  WallTimer createWallTimer(WallDuration period, void(T::*callback)(const WallTimerEvent&), \n                            const boost::shared_ptr<T>& obj, \n                            bool oneshot = false, bool autostart = true) const\n  {\n    WallTimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createWallTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   */\n  WallTimer createWallTimer(WallDuration period, const WallTimerCallback& callback, \n                            bool oneshot = false, bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  WallTimer createWallTimer(WallTimerOptions& ops) const;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Versions of createSteadyTimer()\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.\n   * This variant takes a class member function, and a bare pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on\n   * \\param oneshot If true, this timer will only fire once\n   * \\param autostart If true (default), return timer that is already started\n   */\n  template<class T>\n  SteadyTimer createSteadyTimer(WallDuration period, void(T::*callback)(const SteadyTimerEvent&), T* obj,\n                                bool oneshot = false, bool autostart = true) const\n  {\n    return createSteadyTimer(period, boost::bind(callback, obj, _1), oneshot, autostart);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * a class member function, and a shared pointer to the object to call the method on.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The method to call\n   * \\param obj The object to call the method on.  Since this is a shared pointer, the object will\n   * automatically be tracked with a weak_ptr so that if it is deleted before the Timer goes out of\n   * scope the callback will no longer be called (and therefore will not crash).\n   * \\param oneshot If true, this timer will only fire once\n   */\n  template<class T>\n  SteadyTimer createSteadyTimer(WallDuration period, void(T::*callback)(const SteadyTimerEvent&),\n                                const boost::shared_ptr<T>& obj,\n                                bool oneshot = false, bool autostart = true) const\n  {\n    SteadyTimerOptions ops(period, boost::bind(callback, obj.get(), _1), 0);\n    ops.tracked_object = obj;\n    ops.oneshot = oneshot;\n    ops.autostart = autostart;\n    return createSteadyTimer(ops);\n  }\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant takes\n   * anything that can be bound to a Boost.Function, including a bare function\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param period The period at which to call the callback\n   * \\param callback The function to call\n   * \\param oneshot If true, this timer will only fire once\n   */\n  SteadyTimer createSteadyTimer(WallDuration period, const SteadyTimerCallback& callback,\n                                bool oneshot = false, bool autostart = true) const;\n\n  /**\n   * \\brief Create a timer which will call a callback at the specified rate, using wall time to determine\n   * when to call the callback instead of ROS time.  This variant allows\n   * the full range of TimerOptions.\n   *\n   * When the Timer (and all copies of it) returned goes out of scope, the timer will automatically\n   * be stopped, and the callback will no longer be called.\n   *\n   * \\param ops The options to use when creating the timer\n   */\n  SteadyTimer createSteadyTimer(SteadyTimerOptions& ops) const;\n\n  /** \\brief Set an arbitrary XML/RPC value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param v The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const XmlRpc::XmlRpcValue& v) const;\n  /** \\brief Set a string value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param s The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::string& s) const;\n  /** \\brief Set a string value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param s The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const char* s) const;\n  /** \\brief Set a double value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param d The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, double d) const;\n  /** \\brief Set an integer value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param i The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, int i) const;\n  /** \\brief Set a boolean value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param b The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, bool b) const;\n\n  /** \\brief Set a string vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<std::string>& vec) const;\n  /** \\brief Set a double vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<double>& vec) const;\n  /** \\brief Set a float vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<float>& vec) const;\n  /** \\brief Set a int vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<int>& vec) const;\n  /** \\brief Set a bool vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param vec The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::vector<bool>& vec) const;\n\n  /** \\brief Set a string vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, std::string>& map) const;\n  /** \\brief Set a double vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, double>& map) const;\n  /** \\brief Set a float vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, float>& map) const;\n  /** \\brief Set a int vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, int>& map) const;\n  /** \\brief Set a bool vector value on the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param map The value to be inserted.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  void setParam(const std::string& key, const std::map<std::string, bool>& map) const;\n\n  /** \\brief Get a string value from the parameter server.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] s Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::string& s) const;\n  /** \\brief Get a double value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] d Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, double& d) const;\n  /** \\brief Get a float value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] f Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, float& f) const;\n  /** \\brief Get an integer value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] i Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, int& i) const;\n  /** \\brief Get a boolean value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] b Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, bool& b) const;\n  /** \\brief Get an arbitrary XML/RPC value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] v Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, XmlRpc::XmlRpcValue& v) const;\n\n  /** \\brief Get a string vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<std::string>& vec) const;\n  /** \\brief Get a double vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<double>& vec) const;\n  /** \\brief Get a float vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<float>& vec) const;\n  /** \\brief Get an int vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<int>& vec) const;\n  /** \\brief Get a boolean vector value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::vector<bool>& vec) const;\n\n  /** \\brief Get a string map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, std::string>& map) const;\n  /** \\brief Get a double map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, double>& map) const;\n  /** \\brief Get a float map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, float>& map) const;\n  /** \\brief Get an int map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, int>& map) const;\n  /** \\brief Get a boolean map value from the parameter server.\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParam(const std::string& key, std::map<std::string, bool>& map) const;\n\n  /** \\brief Get a string value from the parameter server, with local caching\n   *\n   * If you want to provide a default value in case the key does not exist use param().\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] s Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::string& s) const;\n  /** \\brief Get a double value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] d Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, double& d) const;\n  /** \\brief Get a float value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] f Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, float& f) const;\n  /** \\brief Get an integer value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] i Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, int& i) const;\n  /** \\brief Get a boolean value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] b Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, bool& b) const;\n  /** \\brief Get an arbitrary XML/RPC value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] v Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, XmlRpc::XmlRpcValue& v) const;\n\n  /** \\brief Get a std::string vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<std::string>& vec) const;\n  /** \\brief Get a double vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<double>& vec) const;\n  /** \\brief Get a float vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<float>& vec) const;\n  /** \\brief Get a int vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<int>& vec) const;\n  /** \\brief Get a bool vector value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] vec Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::vector<bool>& vec) const;\n\n  /** \\brief Get a string->std::string map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, std::string>& map) const;\n  /** \\brief Get a string->double map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, double>& map) const;\n  /** \\brief Get a string->float map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, float>& map) const;\n  /** \\brief Get a string->int map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, int>& map) const;\n  /** \\brief Get a string->bool map value from the parameter server, with local caching\n   *\n   * This method will cache parameters locally, and subscribe for updates from\n   * the parameter server.  Once the parameter is retrieved for the first time\n   * no subsequent getCached() calls with the same key will query the master --\n   * they will instead look up in the local cache.\n   *\n   * \\param key The key to be used in the parameter server's dictionary\n   * \\param[out] map Storage for the retrieved value.\n   *\n   * \\return true if the parameter value was retrieved, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool getParamCached(const std::string& key, std::map<std::string, bool>& map) const;\n\n  /** \\brief Check whether a parameter exists on the parameter server.\n   *\n   * \\param key The key to check.\n   *\n   * \\return true if the parameter exists, false otherwise\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool hasParam(const std::string& key) const;\n  /** \\brief Search up the tree for a parameter with a given key\n   *\n   * This function parameter server's searchParam feature to search up the tree for\n   * a parameter.  For example, if the parameter server has a parameter [/a/b]\n   * and you're in the namespace [/a/c/d], searching for the parameter \"b\" will\n   * yield [/a/b].  If [/a/c/d/b] existed, that parameter would be returned instead.\n   *\n   * \\param key the parameter to search for\n   * \\param [out] result the found value (if any)\n   *\n   * \\return true if the parameter was found, false otherwise.\n   */\n  bool searchParam(const std::string& key, std::string& result) const;\n  /** \\brief Delete a parameter from the parameter server.\n   *\n   * \\param key The key to delete.\n   *\n   * \\return true if the deletion succeeded, false otherwise.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  bool deleteParam(const std::string& key) const;\n\n  /** \\brief Get the keys for all the parameters in the parameter server.\n   * \\param keys The keys retrieved.\n   * \\return true if the query succeeded, false otherwise.\n   */\n  bool getParamNames(std::vector<std::string>& keys) const;\n\n  /** \\brief Assign value from parameter server, with default.\n   *\n   * This method tries to retrieve the indicated parameter value from the\n   * parameter server, storing the result in param_val.  If the value\n   * cannot be retrieved from the server, default_val is used instead.\n   *\n   * \\param param_name The key to be searched on the parameter server.\n   * \\param[out] param_val Storage for the retrieved value.\n   * \\param default_val Value to use if the server doesn't contain this\n   * parameter.\n   * \\return true if the parameter was retrieved from the server, false otherwise.\n   * \\throws InvalidNameException If the parameter key begins with a tilde, or is an otherwise invalid graph resource name\n   */\n  template<typename T>\n  bool param(const std::string& param_name, T& param_val, const T& default_val) const\n  {\n    if (hasParam(param_name))\n    {\n      if (getParam(param_name, param_val))\n      {\n        return true;\n      }\n    }\n\n    param_val = default_val;\n    return false;\n  }\n\n  /**\n   * \\brief Return value from parameter server, or default if unavailable.\n   *\n   * This method tries to retrieve the indicated parameter value from the\n   * parameter server. If the parameter cannot be retrieved, \\c default_val\n   * is returned instead.\n   *\n   * \\param param_name The key to be searched on the parameter server.\n   *\n   * \\param default_val Value to return if the server doesn't contain this\n   * parameter.\n   *\n   * \\return The parameter value retrieved from the parameter server, or\n   * \\c default_val if unavailable.\n   *\n   * \\throws InvalidNameException If the parameter key begins with a tilde,\n   * or is an otherwise invalid graph resource name.\n   */\n  template<typename T>\n  T param(const std::string& param_name, const T& default_val) const\n  {\n      T param_val;\n      param(param_name, param_val, default_val);\n      return param_val;\n  }\n\n  /**\n   * \\brief Shutdown every handle created through this NodeHandle.\n   *\n   * This method will unadvertise every topic and service advertisement,\n   * and unsubscribe every subscription created through this NodeHandle.\n   */\n  void shutdown();\n\n  /** \\brief Check whether it's time to exit.\n   *\n   * This method checks to see if both ros::ok() is true and shutdown() has not been called on this NodeHandle, to see whether it's yet time\n   * to exit.  ok() is false once either ros::shutdown() or NodeHandle::shutdown() have been called\n   *\n   * \\return true if we're still OK, false if it's time to exit\n   */\n  bool ok() const;\n\nprivate:\n  struct no_validate { };\n  // this is pretty awful, but required to preserve public interface (and make minimum possible changes)\n  std::string resolveName(const std::string& name, bool remap, no_validate) const;\n\n  void construct(const std::string& ns, bool validate_name);\n  void destruct();\n\n  void initRemappings(const M_string& remappings);\n\n  std::string remapName(const std::string& name) const;\n\n  std::string namespace_;\n  std::string unresolved_namespace_;\n  M_string remappings_;\n  M_string unresolved_remappings_;\n\n  CallbackQueueInterface* callback_queue_;\n\n  NodeHandleBackingCollection* collection_;\n\n  bool ok_;\n};\n\n}\n\n#endif // ROSCPP_NODE_HANDLE_H\n","     MyClass my_class;","     ros::Publisher pub = handle.advertise<std_msgs::Empty>(\"my_topic\", 1, ","                                                            boost::bind(&MyClass::connectCallback, my_class, _1));"]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":0,"parameter":"topic","direction":null,"children":[{"type":"text","text":" Topic to advertise on"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":1,"parameter":"queue_size","direction":null,"children":[{"type":"text","text":" Maximum number of outgoing messages to be queued for delivery to subscribers"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":2,"parameter":"connect_cb","direction":null,"children":[{"type":"text","text":" Function to call when a subscriber connects"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":3,"parameter":"disconnect_cb","direction":null,"children":[{"type":"text","text":" (optional) Function to call when a subscriber disconnects"}]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"paramcommand","index":4,"parameter":"tracked_object","direction":null,"children":[{"type":"text","text":" (optional) A shared pointer to an object to track for these callbacks.  If set, the a weak_ptr will be created to this object,"},{"type":"text","text":" and if the reference count goes to 0 the subscriber callbacks will not get called."},{"type":"text","text":" Note that setting this will cause a new reference to be added to the object before the"},{"type":"text","text":" callback, and for it to go out of scope (and potentially be deleted) in the code path (and therefore"},{"type":"text","text":" thread) that the callback is invoked from."},{"type":"text","text":" "}]},{"type":"paramcommand","index":5,"parameter":"latch","direction":null,"children":[{"type":"text","text":" (optional) If true, the last message published on this topic will be saved and sent to new subscribers when they connect"},{"type":"text","text":" "}]},{"type":"blockcommand","command":"return","arguments":[],"children":[{"type":"text","text":" On success, a Publisher that, when it goes out of scope, will automatically release a reference"},{"type":"text","text":" on this advertisement.  On failure, an empty Publisher which can be checked with:"}]},{"type":"verbatimcommand","parts":["ros::NodeHandle nodeHandle;","ros::publisher pub = nodeHandle.advertise<std_msgs::Empty>(\"my_topic\", 1, (ros::SubscriberStatusCallback)callback);","if (pub)  // Enter if publisher is valid","{","...","}"]},{"type":"paragraph","children":[{"type":"text","text":" "}]},{"type":"blockcommand","command":"throws","arguments":[],"children":[{"type":"text","text":" InvalidNameException If the topic name begins with a tilde, or is an otherwise invalid graph resource name"}]}],"template_args":null,"params":[],"ret_ty":{"kind":"record","display_name":"ros::Publisher","name":"homepackagesastra_rosastra_ros_apin-ros_c-Publisher","const_qualified":false,"pointee":null,"elaborated":null},"visibility":"default","accessibility":"public","is_ctor":false,"is_dtor":false}}}